# Summary

##  数组

### 数组的基本概念

数组（Array）：数组是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同数据类型**的数据。

* 线性表与非线性表
  * 线性表（Linear List）：数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后2个方向。如：数组、链表、队列、栈等。
  * 非线性表：数据之间不是简单的前后关系。如：二叉树、堆、图等。
* 连续的内存空间和相同类型的数据
  * 正是因为这2个限制，数组具有一个杀手级的特性：**随机访问**。即其根据下标随机访问的时间复杂度为O(1)。但是要**注意**数组中查找一个元素的时间复杂度不是O(1)。
  * 但是也正是因为数组存储需要连续的内存空间，因此其插入和删除操作非常低效，因为为了保证数组数据的连续性，需要做大量的数据搬移工作。

### 数组的基本操作

* 插入：
  * 实现：将某个元素插入到数组第k个位置，需要将k~n部分的元素向后搬移一位，然后插入元素。若插入到数组的末尾，时间复杂度O(1)；插入到数组的开头，时间复杂度O(n)；插入的平均时间复杂度为（1+2+...+n）/n = O(n)。
  * **优化**：若数组只是一个存储数据的集合，其元素是无序的，则插入时不需要搬移数据。此时若想将某个元素插入到数组第k个位置，首先将该位置的元素移动到数组末尾，然后将待插入元素插入到第k个位置，时间复杂度降为O(1)。但是要注意这个优化是针对数组是无序的。
* 删除
  * 实现：若要删除第k个位置的元素，则需要将k+1~n个元素向前搬移一位。若删除数组的末尾，时间复杂度O(1)；删除数组的开头，时间复杂度O(n)；删除平均时间复杂度为 O(n)。
  * **优化**：将多次删除一起执行。当我们要删除多个元素的时候，并不立即进行搬移操作，而是将多个元素标记为已删除，然后当数组满了的时候，将标记的元素一起删除，这样就减少了数组搬移的次数，提高了效率。这就是JVM中标记-清除算法的核心思想。
* 随机访问
  * 实现：数组的随机访问，只需要根据首地址和下标通过寻址公式计算出对应内存地址即可。

### 数组的内存模型

* 访问数组的本质：访问一段连续内存。对内存的要求较高。
* 数组访问寻址公式：
  * 给定一维数组`a[n]`, 则`a[k]`的内存地址为：`a[k]_address = base_address + k * type_size`。
  * 给定二维数组`a[m][n]`则`a[i][j]`的内存地址为：`a[i][j]_address = base_address + (i*n + j) * type_size `。



##  链表

###链表的基本概念

链表（Linked List）：链表是一种**线性表**数据结构。它用一组**不连续的内存空间**，来存储一组具有**相同数据类型**的数据。



### 链表的基本操作

- 插入：链表的插入只需要调整前后节点的指针即可,时间复杂度为O(1)

- 删除：链表的删除只需要调整前后节点的指针即可,时间复杂度为O(1)

- 随机访问：链表的随机访问，无法像数组一样通过寻址公式计算出下标的内存位置，只能通过遍历找到相应的节点，时间复杂度为O(n)。


### 链表的分类：

**1. 单链表**

结构：head ->  x -> y -> null

缺点：只能从头到尾遍历



**2.循环链表**:

结构：head ->  x -> y -> head

优势：与单链表相比，其优势在于可以从尾到头遍历。



**3. 双向链表:**

结构：head <->  x <-> y -> null

优势：双向链表最大的优势在于找到前驱结点的时间复杂度为O(1)，正因为这个特点，使得双向链表在某些情况下，插入、删除等操作要比单链表简单高效，尽管时间复杂度都是O(1)。





### 数组 VS 链表

**1. 内存**

从内存来讲，数组要求内存是一块连续的内存空间，而链表则不需要内存空间连续，例如，如果申请一个100MB大小的数组，当内存中没有连续的大于等于100MB的内存空间时，即使内存的总空间大于100MB，内存也会申请失败；而链表则不需要连续的内存空间，链表通过指针将不同的内存块串联起来，如果内存的总空间大于100MB，那么申请100MB的链表则没有任何问题。



**2. 基本操作**



### LRU缓存淘汰算法 

缓存是一种提高数据读取性能的技术，在软件开发与硬件设计中应用非常广泛，例如CPU缓存、数据库缓存以及浏览器缓存等。



缓存的大小有限，当缓存占满时，就涉及到数据的淘汰问题。常见的缓存淘汰策略有：

* 先进先出策略FIFO(First In, First Out)
* 最少使用策略LFU(Least Frequently Used)
* 最近最少使用策略LRU(Least Recently Used)



## 排序

| 排序方法 | 最好       | 最坏       | 平均       | 额外空间复杂度 | 稳定性 | 原地排序 |
| -------- | ---------- | ---------- | ---------- | -------------- | ------ | :------: |
| 冒泡     | O(n)   | O(n^2)  | O(n^2)   | O(1)         | 是     | 是       |
| 插入     | O(n)    | O(n^2)   | O(n^2)   | O(1)         | 是     | 是       |
| 选择     | O(n^2)   | O(n^2)   | O(n^2)   | O(1)         | 否     | 是       |
| 归并     | O(nlogn) | O(nlogn) | O(nlogn) | O(n)         | 是     | 否       |
| 快排     | O(nlogn) | O(n^2)   | O(nlogn) | O(1)         | 否     | 是       |
| 桶排 | O(n) | - | - | - | 是 | 否 |
| 计数 | O(n+k)(k是数据范围) | - | - | - | 是 | 否 |
| 基数 | O(d*n)(d是维度) | - | - | - | 是 | 否 |



## 二分查找

* 二分查找：高效的有序数据集合查找算法
  * 时间复杂度：O(logn)
  * O(logn)是一个快到很恐怖复杂度。例如：当n=2^32（约42亿）时，logn=32。即从42亿有序数据中二分查找一个数据，最多32次。相反，O(2^n)是一个慢的恐怖的时间复杂度。
* 应用场景：
  * 针对数组，原因是：
    * 数组：根据下标随机访问的时间复杂度O(1)
    * 链表：根据下标随机访问的时间复杂度O(n)
  * 针对有序数据
    * 二分查找只能用在插入、删除操作不频繁的静态数据中，一次排序多次查找的场景中，因为排序最快O(nlogn)
    * 那么动态数据集合如何快速查找某个数据呢？答案是二叉树。
  * 数据量太小不适合二分查找
    * 数据量太小，直接顺序遍历即可，二分查找的优势并不明显
    * 但是如果数据之间的比较操作比较耗时间，那么减少比较操作会大大提高性能，因此即使数据量小，但是二分查找可以减小比较次数，例如数组中存储的是长度超过300的字符串，这样长度的字符串的比较则会非常耗时间。
  * 数据量太大不适合二分查找
    * 二分查找需要依赖数组，而数组为了支持随机访问的特性，要求内存空间是连续的，因此对内存的要求比较苛刻。比如，要存储1GB的数据，则需要1GB的连续内存空间。
    * 这里的**连续**是指：即使有2GB内存空间剩余，但是这些空间是零散的，没有连续的1GB的空间，那照样无法申请一个1GB的数组。
* 问题：假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？
  * 1000 * 10^4 * 8 / 10^6 = 80MB，可以使用数组存储80MB的整数，然后排序，使用二分查找取得某个数据。
  * 大部分情况下，使用二分查找可以解决的问题，散列表和二叉树也可以解决，那么是否可以用散列表或者二叉树呢？答案是否定的。因为散列表和二叉树都需要额外的存储，100MB必然不够。